/********************************
  Деструктурирующее присваивание
********************************/
// Деструктуризация используется чаще всего тогда, когда есть необходимость осуществить присвоение значений сразу
// нескольким переменным, например "распарсить" массив или объект и сохранить его значения в переменные

// ВАЖНО ПОМНИТЬ! КВАДРАТНЫЕ И ФИГУРНЫЕ СКОБКИ В ЛЕВОЙ ЧАСТИ ВЫРАЖЕНИЯ НЕ ГОВОРЯТ О ТОМ, ЧТО МЫ ОБЪЯВЛЯЕМ МАССИВ ИЛИ ОБЪЕКТ
// ОНИ ПРЕДНАЗНАЧЕНЫ ТОЛЬКО ДЛЯ "ГРУППИРОВКИ" ОБЪЯВЛЯЕМЫХ ПЕРЕМЕННЫХ ИЛИ ИНАЧЕ ГОВОРЯ ДЛЯ "ВОССОЗДАНИЯ" СТРУКТУРЫ,
// НАХОДЯЩЕЙСЯ СПРАВА

// РАБОТА С МАССИВАМИ
// В правой части выражения может быть и переменная с массивом
// Запись значений в переменные осуществляется последовательно
let [a, , b] = [1, 2, 3];
// В a запишется 1-й элемент массива, в b - 3-й (одна запятая пропускает один элемент)

[b, a] = [a, b];
// Деструктуризацию можно использовать также для того, чтобы поменять значение переменных местами
// В b запишется значение переменной a, и наоборот, итого - a = 3 и b = 1

// РАБОТА С ОБЪЕКТАМИ
// В правой части выражения может быть и переменная с объектом
let {name: name, age: age, salary: salary} = {name: 'Vasya', age: 25, salary: '2000$'};
// Объект из левой части можно записать сокращенно - {name, age, salary}
// Здесь ключи левого объекта - это имена ключей, по которым из объекта с правой стороны будут браться значения
// Значения левого объекта - это имена новых переменных
// Происходит как бы зеркальное присвоение значения
// Итого в переменную name запишется 'Vasya', в age - 25 и т.д.
// Порядок написания ключей абсолютно не важен, равно как и можно не прописывать в левой части те ключи, которые нет
// необходимости парсить

// УСТАНОВКА ЗНАЧЕНИЙ ПО-УМОЛЧАНИЮ
const list = [1];
let [c = 0, d = 2] = list;
// В переменную c запишется 1-й элемент массива list
// Если бы его не было - записалось бы значение по-умолчанию 0
// В d запишется число 2, т.к. поскольку 2-й элемент у массива list отстутствует (undefined) - возьмется значение по-умолчанию

const obj = {x: 1};
let {x = 0, y = 2} = obj;
// В переменную x запишется значение по ключу x из объекта obj
// Если бы такого ключа в объекте справа не было - записалось бы значение по-умолчанию 0
// В y запишется число 2, т.к. поскольку в объекте obj нет такого ключа и соответственно значения (undefined) - возьмется
// значение по-умолчанию

// ПРИСВОЕНИЕ В ПАРАМЕТРЫ ФУНКЦИИ
// Последовательное присвоение - в name запишется 'string', в val - 25
function f1([name, val]) {
	console.log(name, val);
}
f1(['string', 25]);

// Аналог {name, val} = {name: 'string', val: 25} - см. выше
function f2({name, val}) {
	console.log(name, val);
}
f2({name: 'string', val: 25});

// n и v - это имена параметров (переменных грубо говоря)
// В переменную n запишется значение из переданного объекта по его ключу name, в v - по ключу val
function f3({name: n, val: v}) {
	console.log(n, v);
}
f3({name: 'string', val: 25});

// ВЛОЖЕННОСТЬ В ДЕСТРУКТУРИЗАЦИИ ПРИ РАБОТЕ С МАССИВАМИ
// Сохраняется принцип зеркального отражения
let [m, n, [i, j]] = [1, 2, [3, 4]];

// ВЛОЖЕННОСТЬ В ДЕСТРУКТУРИЗАЦИИ ПРИ РАБОТЕ С ОБЪЕКТАМИ
// Сохраняется принцип зеркального отражения
// Объект из левой части можно записать сокращенно - {param1, nestedParams: {param2}}
// В переменную param1 запишется 'string', в переменную param2 запишется значение по ключу nestedParams.param2 из объекта
// из правой части
// Ключ nestedParams в левой части указывает, по какому ключу осуществлять поиск вложенного объекта в объекте из правой части
// К сожалению, при таком варианте использования пропадает возможность одновременно с парсингом вложенного объекта
// создать переменную nestedParams и поместить в нее этот самый вложенный объект из правой части целиком
let {param1: param1, nestedParams: {param2: param2}} = {param1: 'string', nestedParams: {param2: 40}};

/*********************
  Стрелочные функции
*********************/
// Вместо слова function - () и =>
// Всегда анонимные, не анонимными могут являться лишь при объявлении функции через Function Expression, например
// const func = () => {}
// Работают с внешним контекстом this - в некоторых случаях удобная замена выражения var self = this;
const btn = document.getElementById('button');

btn.addEventListener('click', () => {
	console.log(this); // this будет являться не button, а в данной ситуации Window
});

// Не имеют доступа к псевдомассиву arguments
const numbers = [1, 2, 3];

numbers.forEach(number => {
	console.log(arguments); // Uncaught ReferenceError: arguments is not defined
});

// НЕКОТОРЫЕ СИНТАКСИЧЕСКИЕ ОСОБЕННОСТИ
// Если параметров 0 - пишутся просто круглые скобки
numbers.map(() => {});

// Если параметр 1 - он пишется без скобок
// Если выполняется одна операция - фигурные скобки для действий также не пишутся и вся функция записывается в одну строку
// Если перед этой одной операцией стоит команда return - ее также можно опустить
numbers.map(number => number + 1);

// Если происходит return объекта - его необходимо обернуть в круглые скобки
numbers.map(number => ({count: number}));

// Если параметров больше, чем 1 - они берутся в скобки
// Если выполняется несколько операций - return указывается, фигурные скобки для действий пишутся и функция записывается
// в несколько строк
numbers.map((number, i) => {
	number += i;

	return number;
});

/***********************
  Класс String - Поиск
***********************/
// МЕТОД startsWith()
// Проверяет, начинается ли строка на данную подстроку
'Hello'.startsWith('Hell'); // true
'Hello'.startsWith('ello'); // false

// МЕТОД endsWith()
// Проверяет, заканчивается ли строка на данную подстроку
'Hello'.endsWith('ello'); // true
'Hello'.endsWith('Hell'); // false

// МЕТОД includes()
// С одним параметром - проверяет, содержится ли где-нибудь в строке данная построка
// Второй параметр задает индекс, начиная с которого осуществлять поиск (подстрока необязательно должна начинаться
// именно с данного индекса, она может находиться и правее
'Hello'.includes('ell'); // true

'Hello'.includes('ell', 1); // true
'Heello'.includes('ell', 1); // true
'Heello'.includes('ell', 3); // false

/**************
  Класс Array
**************/
// МЕТОД includes()
// С одним параметром - проверяет, есть ли в массиве такой элемент
// Второй параметр задает индекс, начиная с которого осуществлять поиск (элемент необязательно должен находиться именно
// на данной позиции, он может находиться и правее
const arr = [1, 2, 3];

arr.includes(3); // true
arr.includes(4); // false

arr.includes(3, 1); // true
arr.includes(3, 2); // true
arr.includes(3, 3); // false

// ЦИКЛ For of - используется для массивов - для перебора его значений
for (let value of arr) {
	console.log(value);
} // 1, 2, 3

// и для HTML-коллекций - для перебора DOM-объектов
const blocks = document.getElementsByTagName('div');

for (let block of blocks) {
	console.log(block.tagName);
} // 'DIV', 'DIV'...