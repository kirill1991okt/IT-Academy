React.js:
  - React быстрый, простой в изучении и по нему легко находить информацию в интернете
  - Его киллер-фича заключается в использовании Virtual DOM. Операции с DOM самые дорогостоящие по времени, потому в
    React все изменения сначала выполняются в виртуальном варианте, а затем за раз вставляются в реальный DOM

  Properties:
    - Properties нужны только для чтения
    - propTypes используются для валидации типа или формата данных свойств

  State:
    - this.state - не записывается напрямую, поскольку во-первых произойдет перезатирание предыдущей информации,
      во-вторых React не узнает, что state изменился и ему нужно что-то перерисовать
    - Метод setState() - может принимать объект и функцию. Из-за асинхронной природы setState() функция позволяет
      гарантированно получать последнее обновленное значение какого-либо свойства
    - Нельзя вызывать setState() в render() иначе произойдет зацикливание перерисовок

  Жизненный цикл компонента:
    Прикручивание компонента:
      constructor():
        - Вызывается при инициализации компонента
        - Здесь можно объявлять всё, что записывается в this, также делать привязку событий через bind
        - Состояние здесь можно записать напрямую в this.state
      componentWillMount() (deprecated):
        - Компонент будет примонтирован
        - Сейчас логика работы метода мало чем отличается от constructor()
        - setState() здесь не вызовет перерисовку компонента
        - Сайд-эффекты здесь лучше не использовать, т.к. они не успеют завершиться до render()
      getDerivedStateFromProps(nextProps, prevState):
        - Здесь можно установить начальное состояние компонента из props
      render():
        - Отрисовка компонента в VDOM
      componentDidMount():
        - Компонент был примонтирован
        - Вызывается лишь раз, здесь можно выполнять сайд-эффекты

    Перерисовка компонента:
      componentWillReceiveProps(nextProps) (deprecated):
        - Вызывается при каждом обновлении компонента, которое происходит при изменениях в props (когда перерисовывается
          родительский компонент)
        - Вызывается со всеми props, даже с теми, что не менялись, в связи с чем необходимо писать проверку, чтобы понять,
          поменялось ли значение какого-либо свойства или нет
        - Может быть вызвана несколько раз, сайд-эффекты здесь лучше не использовать
      getDerivedStateFromProps(nextProps, prevState):
        - Метод убеждается, что state и props синхронизированы, когда это необходимо
      shouldComponentUpdate(nextProps, nextState, nextContext):
        - Метод для определения вручную, стоит ли производить перерисовку компонента
        - Должен возвращать boolean
      componentWillUpdate(nextProps, nextState) (deprecated):
        - Компонент будет обновлен
        - Может быть вызвана несколько раз, сайд-эффекты здесь лучше не использовать
      render()
      getSnapshotBeforeUpdate(prevProps, prevState):
        - Вызывается в "pre-commit" фазе, прямо перед отображением изменений из VDOM в DOM
        - Можно использовать, если нужно прочитать текущее состояние DOM и что-то из него сохранить (напр. позицию скролла)
      componentDidUpdate(prevProps, prevState, prevContext):
        - Компонент и его дочерние компоненты перерисовались
        - Вызывается лишь раз, здесь можно выполнять сайд-эффекты

    Удаление компонента:
      componentWillUnmount():
        - Компонент будет отмантирован
        - Здесь можно очищать или закрывать операции из компонента (напр. таймеры)

  Что нового в React:
    Методы getDerivedStateFromProps() и getSnapshotBeforeUpdate()

    Context:
      - https://learn-reactjs.ru/core/context
      - Позволяет передавать данные через дерево компонентов без необходимости передавать props на промежуточных уровнях
      - Лучше использовать тогда, когда есть необходимость использовать одни и те же данные в компонентах на разных
        уровнях вложенности
      - Компонент Provider передает значение value
      - Компонент Consumer принимает его (напр. цветовая тема)

    Хуки:
      - Позволяют использовать React без классов
      - React предоставляет несколько встроенных хуков, возможно создавать свои собственные хуки для повторного
        использования поведения, связанного с состоянием, в различных компонентах
      - Управляют локальным состоянием компонента
      - UseState - отвечает за состояние в функциональных компонентах
      - UseEffect - отвечает за действие, происходящее сразу после рендеринга
      - UseReducer

    ForwardRef:
      - Позволяет взять ref из атрибутов компонента, и перенаправить его одному из дочерних компонентов

  Паттерны разработки на React:
    Conditional rendering:
      - Отрисовка компонента или его части в зависимости от условия
    High ordered components:
      - Это функция, которая принимает входной компонент и возвращает расширенную или изменённую версию этого компонента,
        добавляет что-то поверх основной функциональности - разметку или свойства (напр. HOC делает проверку на залогиненность
        пользователя и передает соответствующее свойство в компоненты, в зависимости от значения которого происходит
        дорисовка доп. информации для авторизованного пользователя)
      - Используются для того, чтобы избежать дублирование кода в нескольких компонентах - реюзабельность
    Container/Presentational components:
      - Container-компонент работает с данными и поведением компонента, имеет состояние, не имеет разметки
      - Presentational-компонент отвечает за отрисовку и внешний вид компонента, данные получает из свойств,
        не имеет зависимостей и состояния
    Controlled/uncontrolled components:
      - В управляемом компоненте данные формы обрабатываются с помощью обработчиков
        событий и использования state. В неуправляемом, вместо того, чтобы писать обработчик события для каждого
        обновления состояния, можно читать значения из DOM через ref

  Оптимизация скорости работы приложения на React:
    Lazy load:
      - Помогает организовать код сплиттинг, при котором некоторые компоненты подключаются динамически, то есть
        импортируются сразу, а подгружаются когда необходимо
    Pure component:
      - Изменяет метод shouldComponentUpdate(), автоматически проверяя, нужно ли заново отрисовывать компонент
      - Будет вызывать render() только если обнаружит изменения в state или props компонента (не изменения содержимого,
        а именно если получит ссылку на новый объект)

Redux, thunk:
  - https://iamakulov.com/talks/redux-in-real-life/

  Persist:
    - Используется для сохранения данных Redux при перезагрузке страницы
    - Можно настроить таким образом, чтобы сохранялся весь store или какой-то конкретный reducer для того, чтобы
      при перезагрузке страницы в reducer-е было сразу последнее состояние

