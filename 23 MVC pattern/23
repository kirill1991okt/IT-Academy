MV-ПАТТЕРНЫ
  MVC:
    - Схема - см. скрин
    - Controller - отвечает за обработку происходящих на странице событий, связанных с Моделью или Представлением
    - Model - хранит информацию о какой-либо сущности и методы для управления ею (создание, получение, редактирование,
      удаление и т.д.)
    - View - отвечает за отрисовку данных из Модели

    Виды MVC:
      Активный:
        - Пользователь на странице регистрации заполнил данные о себе и нажал "Зарегистрироваться". Контроллер
          отследил это действие и вызвал метод save() Модели, который в свою очередь отправит данные из формы на сервер.
          После этого Представление сможет прочитать информацию из Модели и отобразить ее пользователю на странице,
          например в виде "Пользователь 'Вася' успешно зарегистрирован"
      Пассивный:
        - В пассивном MVC Контроллер будет сам собирать данные из формы и отправлять их на сервер вместо Модели, то есть
          логика работы методов Модели будет находиться в Контроллере

  MVVM:
    - Схема - см. скрин
    - ViewModel выполняет роль Контроллера и связующего звена между Моделью и Представлением
    - Пример - пользователь нажал на кнопку "Получить список пользователей" в Представлении (разметке). Представление
      Модели услышало это событие и вызвало метод Модели getAll(), который отправил соответствующий запрос на сервер. С
      сервера пришел список Моделей пользователей (Коллекция), Представление Модели узнало об этом и отобразило этот
      список в Представлении (разметке). Такая работа осуществляется благодаря двустороннему data-binding-у.

SPA
  - K.46 - Single Page Application

МОДУЛИ ES6
  - Модуль - файл с js-кодом. В 1 файле содержится 1 модуль - см. пример
  - Для подключения скрипта-модуля в html необходимо использовать type="module"
  - В модуле могут храниться переменные, объекты, функции, классы - что угодно
  - Нет глобальной области видимости
  - Слайд O.65 - Модули ES6 - пример экспортов и импортов
  - При импорте создаётся не копия внутренностей модуля, а непосредственная привязка к ним. То есть, если после
    импорта модуля внутри него изменить значение некой переменной со строкой - в месте импорта этого модуля оно также
    изменится
  - Иногда два модуля с похожей логикой совмещают в одном, например Add/Edit

ПРИЛОЖЕНИЕ
  Запуск приложения:
    - Установить программу Fenix Web Server
    - Запустить сервер с приложением
  Разбор приложения:
    - Приложение построено по принципу MV*, то есть Представление отслеживает события, вызывает методы Модели и меняет
      вид страницы (то есть выполняет роль и Контроллера, и Представления)
    - См. скрины

ДОПОЛНИТЕЛЬНАЯ ИНФОРМАЦИЯ *
  - Шпаргалка по MV* паттернам - https://habr.com/ru/post/151219/

ДОМАШНЕЕ ЗАДАНИЕ (без переносов)
  Задание 1:
    Реализовать очищение списка задач по кнопке с предварительным подтверждением. При пустом списке задач записывать в
    LS пустой массив.

  Задание 2:
    Реализовать подсчёт количества задач и уведомление о пустом списке задач.

  Задание 3:
    Реализовать логику работы с полем Description. Добавить его в добавление задачи, показывать его в информации и
    добавить возможность редактировать описание. Поле опциональное, поэтому на дизэйблинг кнопок Add/Edit не влияет.
    Работа приложения после перезагрузки страницы должна быть корректной.

  Задание 4 *:
    Реализовать логику работы кнопки Done. При нажатии на нее выполненная задача должна меняться стилистически, кнопки
    Edit и Done должны убираться. Возможность редактирования должна быть заблокирована. Также
    должен меняться статус в данных, должно корректно работать отображение после перезагрузки страницы и счетчик задач
    должен содержать информацию о количестве выполненных задач из всех.
